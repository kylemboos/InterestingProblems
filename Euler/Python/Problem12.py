'''
Problem 12:

The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
'''

#written by: Kyle Boos

'''
thoughts: first i'll go ahead and code up the brute force solution to get a feel for the problem.
		  so the problem is difficult because of the amount of work we have to do to look through every potential divisor.	

		  A different solution below that is still very simple is rather than checking the mod of each number up to n,
		  we can actually divide the number and see if the result is an integer and add that number to the list as well.
		  This way we need to do sqrt(n) work rather than n for each triangle number. This answer is not optimal but is achieved in less than 10 seconds
		  and is how I solved the problem on Euler.
		  
		  
		  Another interesting thought.. what if we kept a map that stored the triangle number to its list of factors and only calculated the factors from the last highest triangle number
		  if there is one that factors into the current triangle number. Dynamic Programming!
		  .
		  .
		  .
		  Well that didn't work. You start skipping factors for larger numbers right away. since 6 picks up the factors of 3 (1,3) it misses 2 since you start at 3.
		  I thought a dynamic programming solution would be interesting but I don't think it wokrs in the case of factors like in this problem.
		  I'll leave the code but like I said it is not an actual solution.
'''
import math

def getDivisors(n):
	divisors = 2
	for i in range(2,int(math.sqrt(n))):
		if n % i == 0:
			divisors+=2
	return divisors

def withMap(n, map):
	if n == 1:
		map[1] = [1]
		return map
		
	divisors = []	
	start = 2
	for k in sorted(map.keys(),reverse=True):
		if n % k == 0:
			for d in map[k]:
				divisors.append(d)
			start = k
			break
	if start == 1:
		start = 2
	for i in range(start,int(math.sqrt(n))):
		if n % i == 0:
			divisors.append(i)
			divisors.append(n/i)
	divisors.append(n)
	map[n] = divisors
	return map

#Solution that attempts to use the previous factors dynamically... fail.
'''map = {}

triangle = 1
count = 2

while True:
	map = withMap(triangle, map)
	if len(map[triangle]) >= 7:
		print triangle
		break
	triangle+=count
	count+=1'''

#For just finding the number of factors	
triangle = 1
count = 2

while True:
	if getDivisors(triangle) >= 5:
		print triangle
		break
	triangle+=count
	count+=1
